# 手写代码

#### instanceof

> `instanceof`判断原型链指向。

```javascript
function instanceOf(a, b) {
  // 通过 typeof 判断基本类型
  if (typeof a !== 'object' || b === null) {
    return false
  }

  // getPrototypeOf 是 Object 自带的一个方法
  // 可以拿到参数的原型对象
  let proto = Object.getPrototypeOf(a)
  const prototype = b.prototype

  // 从当前 __proto__ 开始查找
  while (proto) {
    
    // 如果找到 null 还没有找到，返回 false
    if (proto === null) {
      return false
    }

    // 如果 a.__proto__.xxx === b.prototype，返回 true
    if (proto === prototype) {
      return true
    }

    // 进一步迭代
    proto = proto.__proto__
  }
}
```

#### Array.prototype.map

> `map()` 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。

```javascript
function map(arr, mapCallback) {
  // 首先，检查传递的参数是否正确。
  if (!Array.isArray(arr) || !arr.length || typeof mapCallback !== 'function') { 
    return []
  } else {
    let result = []
    // 每次调用此函数时，我们都会创建一个 result 数组
    // 因为我们不想改变原始数组。
    for (let i = 0, len = arr.length; i < len; i++) {
      result.push(mapCallback(arr[i], i, arr))
      // 将 mapCallback 返回的结果 push 到 result 数组中
    }
    return result
  }
}
```

#### Array.prototype.filter

> `filter() `方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。

```javascript
function filter(arr, filterCallback) {
  // 首先，检查传递的参数是否正确。
  if (!Array.isArray(arr) || !arr.length || typeof filterCallback !== 'function') 
  {
    return []
  } else {
    let result = []
     // 每次调用此函数时，我们都会创建一个 result 数组
     // 因为我们不想改变原始数组。
    for (let i = 0, len = arr.length; i < len; i++) {
      // 检查 filterCallback 的返回值是否是真值
      if (filterCallback(arr[i], i, arr)) { 
      // 如果条件为真，则将数组元素 push 到 result 中
        result.push(arr[i])
      }
    }
    return result; // return the result array
  }
}
```

#### Array.prototype.reduce

> `reduce()`方法对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。

```javascript
function reduce(arr, reduceCallback, initialValue) {
  // 首先，检查传递的参数是否正确。
  if (!Array.isArray(arr) || !arr.length || typeof reduceCallback !== 'function') 
  {
    return []
  } else {
    // 如果没有将initialValue传递给该函数，我们将使用第一个数组项作为initialValue
    let hasInitialValue = initialValue !== undefined
    let value = hasInitialValue ? initialValue : arr[0]

    // 如果有传递 initialValue，则索引从 1 开始，否则从 0 开始
    for (let i = hasInitialValue ? 1 : 0, len = arr.length; i < len; i++) {
      value = reduceCallback(value, arr[i], i, arr);
    }
    return value
  }
}
```

#### new

> `new`用来实例化构造函数。

```javascript
function myNew(func, ...args) {
  // 1. 判断方法体
  if (typeof func !== 'function') {
    throw '第一个参数必须是方法体'
  }

  // 2. 创建新对象
  const obj = {}

  // 3. 这个对象的 __proto__ 指向 func 这个类的原型对象
  // 即实例可以访问构造函数原型（constructor.prototype）所在原型链上的属性
  obj.__proto__ = Object.create(func.prototype)
  // 为了兼容 IE 可以让步骤 2 和 步骤 3 合并
  // const obj = Object.create(func.prototype)

  // 4. 通过 apply 绑定 this 执行并且获取运行后的结果
  let result = func.apply(obj, args)
  
  // 5. 如果构造函数返回的结果是引用数据类型，则返回运行后的结果
  // 否则返回新创建的 obj
  const isObject = typeof result === 'object' && typeof result !== null
  const isFunction = typeof result === 'function'

  return isObject || isFunction ? result : obj
}
```

#### 柯里化

> 函数柯里化是把**接受多个参数的函数变换成接受一个单一参数**（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。

##### 主要作用

- 参数复用
- 提前返回 – 返回接受余下的参数且返回结果的新函数
- 延迟执行 – 返回新函数，等待执行

##### 实现
```javascript
const curry = (fn, ...args) => 
	args.length < fn.length
		// 参数长度不足时，重新柯里化该函数，等待接受新函数
		? (...arguments) => curry(fn, ...args, ...arguments)
		// 参数长度满足时，执行函数
		: fn(...args)
```

#### Function.prototype.call

> apply() 方法调用一个函数, 其具有一个指定的this值，以及若干个**参数列表**。

```javascript
Function.prototype.myCall = function (context = window, ...args) {
    // 创建个独一无二的方法名
    const fn = Symbol('fn')
    // 方法变换执行对象
    context[fn] = this
    // 将这个方法的执行结果传给res
    let res = context[fn](...args)
    // 删除对象属性fn
    delete context[fn]
    // 返回结果
    return res
}
```

#### Function.prototype.apply

> apply() 方法调用一个函数, 其具有一个指定的this值，以及作为一个**数组(或类似数组的对象)**提供的参数。

```javascript
Function.prototype.myApply = function (context = window, args) {
    // 创建个独一无二的方法名
    const fn = Symbol('fn')
    // 方法变换执行对象
    context[fn] = this
    // 将这个方法的执行结果传给res
    let res = context[fn](...args)
    // 删除对象属性fn
    delete context[fn]
    // 返回结果
    return res
}
```

#### Function.prototype.bind

> bind()方法创建一个新的函数, 当被调用时，将其this关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的**参数列表**，bind 是创建一个新的函数，我们**必须要手动去调用**。

```javascript
Function.prototype.myBind = function (context = window,...args) {
    // 设置 fn 为调用 myBind 的方法
    const self = this
    
    // 设置返回的一个新函数
    const res = function (...resArgs) {
        // 如果是通过 new 调用的，绑定 this 为实例对象
        if (this instanceof res) {
            self.apply(this, args.concat(...resArgs))
        // 否则普通函数形式绑定 context
        } else {
            self.apply(context, args.concat(...resArgs))
        }
    }
    
    // 绑定原型链
    res.prototype = Object.create(fn.prototype)
    // 返回结果
    return res
} 
```

#### 简版 Promise

> 1. promise 有三个状态：`pending`，`fulfilled`，or `rejected`；「规范 Promise/A+ 2.1」
>
> 2. `new promise`时， 需要传递一个`executor()`执行器，执行器立即执行；
>
> 3. `executor`接受两个参数，分别是`resolve`和`reject`；
>
> 4. promise  的默认状态是 `pending`；
>
> 5. promise 有一个`value`保存成功状态的值，可以是`undefined/thenable/promise`；「规范 Promise/A+ 1.3」
>
> 6. promise 有一个`reason`保存失败状态的值；「规范 Promise/A+ 1.5」
>
> 7. promise 只能从`pending`到`rejected`, 或者从`pending`到`fulfilled`，状态一旦确认，就不会再改变；
>
> 8. promise 必须有一个`then`方法，then 接收两个参数，分别是 promise 成功的回调 onFulfilled, 和 promise 失败的回调 onRejected；「规范 Promise/A+ 2.2」
>
> 9. 如果调用 then 时，promise 已经成功，则执行`onFulfilled`，参数是`promise`的`value`；
>
> 10. 如果调用 then 时，promise 已经失败，那么执行`onRejected`, 参数是`promise`的`reason`；
>
> 11. 如果 then 中抛出了异常，那么就会把这个异常作为参数，传递给下一个 then 的失败的回调`onRejected`；

```javascript
// 三个状态：PENDING、FULFILLED、REJECTED
const PENDING = 'PENDING'
const FULFILLED = 'FULFILLED'
const REJECTED = 'REJECTED'

class Promise {
    constructor(executor) {
        // 默认状态为PENDING
        this.status = PENDING
        // 存放成功的状态，默认为undefined
        this.value = undefined
        // 存放失败状态的值，默认为undefined
        this.reason = undefined
        
        // 存放成功的回调
    	this.onResolvedCallbacks = []
        // 存放失败的回调
        this.onRejectedCallbacks= []
        
        // 调用此方法就是成功
        let resolve = (value) => {
            // 状态为 PENDING 时才可以更新状态，防止executor中调用了两次resolve/reject方法
            if (this.status === PENDING) {
                this.status = FULFILLED
                this.value = value
                // 依次将对应的函数执行
                this.onResolvedCallbacks.forEach(fn => fn())
            }
        }
        
        // 调用此方法就是失败
        let reject = (reason) => {
            // 状态为 PENDING 时才可以更新状态，防止executor中调用了两次resolve/reject方法
            if (this.status === PENDING) {
                this.status = REJECTED
                this.reason = reason
                // 依次将对应的函数执行
                this.onRejectedCallbacks.forEach(fn => fn())
            }
        }
        
        try {
            // 立即执行，将resolve和reject函数传给使用者
            executor(resolve, reject)
        } catch (error) {
            reject(error)
        }
    }
    
    then (onFulfilled, onRejected) {
        if (this.status === FULFILLED) {
            onFulfilled(this.value)
        }
        
        if (this.status === REJECTED) {
            onRejected(this.reason)
        }
        
        if (this.status === PENDING) {
            // 如果promise的状态是 pending
            // 需要将 onFulfilled 和 onRejected 函数存放起来，等待状态确定后，再依次将对应的函数执行
            this.onResolvedCallbacks.push(() => {
                onFulfilled(this.value)
            })
            
            this.onRejectedCallbacks.push(() => {
                onRejected(this.reason)
            })
        }
    }
}
```

