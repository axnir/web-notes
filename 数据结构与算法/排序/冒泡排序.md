# 冒泡排序
> 冒泡排序是一种简单直观的排序算法，它重复性地访问要排序的数列。通过在访问过程中不断地判断和交换相邻数列，从而使最大/小的数往末端转移，最终得到有序数列。

##### 思想

- 冒泡排序只会操作相邻的两个数据
- 每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换
- 一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作


##### 思路
1. 从前两个元素`arr[0]`,`arr[1]`开始，按照顺序两两比较相邻的元素，如果顺序错误就交换。
2. 当第一遍全部比较一遍之后，整个数列中最大的数就会被交换到最后到位置`arr[length-1]`。
3. 第二遍我们重复步骤1的交换，比较到倒数第二个元素位置，因为最末元素已经确定是最终结果了，所以没必要再进行比较处理。
    像步骤3一样，接下来的每一次都重复比较，每次比较都会少比较一次。
4. 当完成最后两个数的比较之后，冒泡排序结束。

##### 特点
- 优点：排序算法的基础，简单实用易理解
- 缺点：比较次数多，效率比较低

##### 代码实现
```javascript
/**
 * 冒泡排序
 * @param {Array} arr 传入一个数组,按照从小到大排序
 * @returns {Array} 返回排序后的数组
 */
function bubbleSort (arr) {
    let len = arr.length
		// 不必到最后一个元素，最后一个元素后边没有元素了
    for (let i = 0; i < len - 1; i++) {
      	// 提前退出冒泡循环的标志位
        let hasChange = false 
        // 最后一个就是最大的，下一次不需要再比较
        for (let j = 0; j< len - i - 1; j++) {
            if(arr[j] > arr[j+1]) {
                // 使用ES6解构赋值
                [arr[j], arr[j+1]] = [arr[j+1], arr[j]]
              	// 表示有数据交换
                hasChange = true
            }
        }
      	// 如果 false 说明所有元素已经到位，没有数据交换，提前退出
        if (!hasChange) break 
    }
    return arr
}
```
##### 分析

- 第一，冒泡排序是原地排序算法吗 ？
  冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为 O(1)，是一个`原地`排序算法。
- 第二，冒泡排序是稳定的排序算法吗 ？
  在冒泡排序中，只有交换才可以改变两个元素的前后顺序。
  为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，我们不做交换，相同大小的数据在排序前后不会改变顺序。
  所以冒泡排序是`稳定`的排序算法。
- 第三，冒泡排序的时间复杂度是多少 ？
  最佳情况：T(n) = O(n)，当数据已经是正序时
  最差情况：T(n) = O(n<sup>2</sup>)，当数据是反序时
  平均情况：T(n) = O(n<sup>2</sup>)。