# 插入排序
> 顺序遍历每一个数，将当前数和之前的数依次比较，并插入到之前到正确位置。
##### 思路
1. 从第一个元素开始，该元素可以认为已经被排序；
2. 取出下一个元素，在已经排序的元素序列中从后向前扫描；
3. 如果该元素（已排序）大于新元素，将该元素移到下一位置；
4. 重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置；
5. 将新元素插入到该位置后；
6. 重复步骤 2~5。

##### 实现
```javascript
/**
* 插入排序
* tip:就像玩扑克牌的时候整理顺序一样
* @param {Array} arr 传入一个数组,按照从小到大排序
* @returns {Array} 返回排序后的数组
*/
function insertionSort (arr) {
    const len = arr.length
    if (len <= 1) return
    
    let current, preIndex
    for (let i = 1; i < len; i++) {
        preIndex = i - 1 // 待比较元素的下标
        current = arr[i] // 当前元素
        while (preIndex >= 0 && arr[preIndex] > current) {
        // 前置条件之一: 待比较元素比当前元素大
            arr[preIndex + 1] = arr[preIndex] // 将待比较元素后移一位
            preIndex-- // 游标前移一位
        }
        // 将current移动到相应位置
        arr[preIndex + 1] = current // 将当前元素插入预留空位
    }
    return arr
}
```
##### 分析

- 第一，插入排序是原地排序算法吗 ？
  插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是 O(1)，所以，这是一个`原地`排序算法。
- 第二，插入排序是稳定的排序算法吗 ？
  在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是`稳定`的排序算法。
- 第三，插入排序的时间复杂度是多少 ？
  最佳情况：T(n) = O(n)，当数据已经是正序时
  最差情况：T(n) = O(n<sup>2</sup>)，当数据是反序时
  平均情况：T(n) = O(n<sup>2</sup>)。