# 选择排序

##### 思路

1. 在未排序序列中找到最小（大）元素，存放到排序序列的起始位置
2. 从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾
3. 重复第二步，直到所有元素均排序完毕

##### 实现
```javascript
/**
 *  选择排序
 * @param {Array} arr 传入一个数组,按照从小到大排序
 * @returns {Array} 返回排序后的数组
 */
const selectionSort = function (arr) {
    const len = arr.length
    // minIndex是最小值的的下标
    let minIndex
    // 需要以len-1个数为基准来判断剩下的数是否需要交换
    for (let i = 0; i < len - 1; i++) {
        // 当前基准数
        minIndex = i
        //循环之后，可以将最小值下标标记出来
        for (let j = i + 1; j < len; j++) {
            // 寻找最小的数
            if (arr[j] < arr[minIndex]) {
                // 将最小数的索引保存
                minIndex = j
            }
        }
        // 将最小值与基准值交换
        [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]]
    }
    return arr
}
```
##### 分析
- 第一，选择排序是原地排序算法吗 ？
  选择排序空间复杂度为 O(1)，是一种`原地`排序算法。
- 第二，选择排序是稳定的排序算法吗 ？
  选择排序每次都要找剩余未排序元素中的最小值，并和前面的元素交换位置，这样破坏了稳定性。所以，选择排序是一种`不稳定`的排序算法。
- 第三，选择排序的时间复杂度是多少 ？
  无论是正序还是逆序，选择排序都会遍历 n2 / 2 次来排序，所以，最佳、最差和平均的复杂度是一样的。
  最佳情况：T(n) = O(n<sup>2</sup>)
  最差情况：T(n) = O(n<sup>2</sup>)
  平均情况：T(n) = O(n<sup>2</sup>)