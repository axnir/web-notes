# Vue面试题

### 对SPA单页面的理解

> SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。

###### 优点

- 用户体验好、快，内容的改变不需要重新加载整个页面，避免不必要的跳转和重复渲染
- SPA相对对服务器压力小
- 前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理

###### 缺点
- 初次加载耗时多：为实现单页Web应用功能以及显示效果，需要在加载页面时将JavaScript、CSS统一加载，部分页面按需加载
- 前进后退路由管理：由于单页应用在一个页面中显示所有内容，所以不能使用路由器前进后退功能，所有页面切换需要自己建立堆栈管理
- SEO难度大：所有的内容都在一个页面中动态替换显示

### v-show与v-if有什么区别

**v-if**是真正的条件渲染，因为他会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是**惰性的**：因为在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时才会开始渲染条件块。

**v-show**不管条件是都真假都会渲染，为假时相当于display: none;

所以，v-if适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show则适合于需要非常频繁切换条件的场景。

### Class与Style如何动态绑定

Class可以通过对象语法和数组语法进行动态绑定：

- 对象语法：

  ```vue
  <div :class="{ active: isActive, 'text-danger': hasError }"></div>
  
  data() {
      return {
  		isActive: true,
  		hasError: false
      }
  }
  ```
  
- 参数语法：

    ```vue
    <div :class="[isActive ? activeClass : '', errorClass]"></div>
    
    ```

data() {
    	return {
    		activeClass: 'active',
    		errorClass: 'text-danger'
    	}
    }
    ```

Style也可以通过对象语法和数组语法进行动态绑定

- 对象语法：

  ```vue
  <div :style="{ color: activeColor, fontSize: fontSize + 'px' }"></div>
  
  data() {
  	return {
  		activeColor: 'red',
  		fontSize: 30
  	}
  }
  ```

- 数组语法：

  ```vue
  <div :style="[styleColor, styleSize]"></div>
  
  data() {
  	return {
  		styleColor: {
  			color: 'red'
  		},
  		styleSize: {
  			fontSize: '30px'
  		}
  	}
  }
  ```


### Vue单向数据流

所有的prop都使其父子 prop 之间形成一个**单项下行绑定**：父级 prop 的更新会向下流动到子组件中，但是反过来不行。这样会防止子组件意外改变父级组件的状态，从而导致应用的数据流难以理解。

其次，每次父级组件发生变化时，子组件所有的 prop 都将会刷新为最新的值。这意味着不应该在一个子组件内部改变 prop 。如果修改，Vue会在浏览器控制台中发出警告。子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件收到后，由父组件修改。

有两种常见的试图改变一个 prop 的情形：

- **这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用**。在这种情况下，最好定义一个本地的 data 属性并将这 prop 用作其初始值：

  ```javascript
  props: ['initialCounter'],
  data () {
  	return {
  		counter: this.initialCounter
  	}
  }
  ```
  
- **这个 prop 以一种原始的值传入且需要进行转换**。在这种情况下，最好使用这个 prop 的值来定义一个计算属性：

  ```javascript
  props: ['size'],
  computed: {
      normallizedSize () {
          return this.size.trim().toLowerCase()
      }
  }
  ```

### computed 和 watch 的区别和运用场景

>  **computed：**是计算属性，依赖其他属性值，并且 computed 的值有缓存，只有它依赖的属性值发生变化，下一次获取 computed 的值时才会重新计算 computed 的值；
>
> **watch：**更多的是「观察」的作用，类似于某些数据的监听回调，每当坚挺的数据变化时都会执行回调进行后续操作；

###### 运用场景：

- 当需要进行数值计算，并且依赖于其他数据时，应该使用 computed ，因为可以利用 computed 的缓存特性，避免每次获取值时都需要重复计算；
- 当需要在数据变化执行时异步或者开销较大的操作时，应该使用 watch ,使用 watch 允许执行异步操作（访问一个API），限制我们执行该操作的频率，并在得到这个最终结果前，设置中间状态。这些都是计算属性无法做到的。