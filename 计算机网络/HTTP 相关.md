# HTTP 相关

## HTTP 缓存

#### 1. 什么是缓存

> 浏览器缓存(Browser Caching)是浏览器对之前请求过的文件进行缓存，以便下一次访问时重复使用，节省带宽，提高访问速度，降低服务器压力。

http缓存机制主要在http响应头中设定，响应头中相关字段为Expires、Cache-Control、Last-Modified、Etag

#### 2. 浏览器如何判断是否使用缓存

- 第一次请求

  <img src="C:/Data/Repo/web-notes/pics/网页初次请求.png" alt="初次请求" style="zoom:70%;" />

- 第二次请求相同页面

  <img src="C:/Data/Repo/web-notes/pics/请求相同页面.png" alt="请求相同页面" style="zoom:70%;" />

#### 3. 缓存的类别

>浏览器缓存分为**强缓存**和**协商缓存**。

##### 强缓存类型：

浏览器不会像服务器发送任何请求，直接从本地缓存中读取文件并返回 `Status Code: 200 OK`

**优先访问memory cache,其次是disk cache，最后是请求网络资源**

`200 form memory cache` : 不访问服务器，一般已经加载过该资源且缓存在了内存当中，直接从内存中读取缓存。浏览器关闭后，数据将不存在（资源被释放掉了），再次打开相同的页面时，不会出现from memory cache。

<img src="C:/Data/Repo/web-notes/pics/200disk.webp" alt="200 from disk cache" style="zoom:80%;" />

`200 from disk cache`： 不访问服务器，已经在之前的某个时间加载过该资源，直接从硬盘中读取缓存，关闭浏览器后，数据依然存在，此资源不会随着该页面的关闭而释放掉下次打开仍然会是from disk cache。

<img src="C:/Data/Repo/web-notes/pics/200memory.webp" alt="200 from memory cache" style="zoom:80%;" />



##### 协商缓存：

向服务器发送请求，服务器会根据这个请求的request header的一些参数来判断是否命中协商缓存，如果命中，则返回304状态码并带上新的response header通知浏览器从缓存中读取资源。

  ![304](C:/Data/Repo/web-notes/pics/304.webp)

#### 4. 强缓存和协商缓存的`header`参数

##### ① 强缓存的 header：

  > `Cache-Control`是 HTTP/1.1 的头字段，`Expires`是 HTTP/1.0 的头字段,如果两者同时存在，`Cache-Control`会覆盖`Expires`，建议两个都写。

  `Expires`：在 HTTP/1.0 中被定义过期时间，如果设置了时间，则浏览器会在设置的时间内直接读取缓存，不再请求。

  `Cache-Control`：在 HTTP/1.1 中被定义的，它可以用于取代之前的缓存策略，现在所有的浏览器都支持，它已经成为一种通用的标准。

  Cache-Control参数如下：

|   参数   |                             作用                             |
| :------: | :----------------------------------------------------------: |
| max-age  | 用来设置资源（representations）可以被缓存多长时间，单位为秒  |
| s-maxage |      和max-age是一样的，不过它只针对代理服务器缓存而言       |
|  public  |                  指示响应可被任何缓存区缓存                  |
| private  |           只能针对个人用户，而不能被代理服务器缓存           |
| no-cache | 强制客户端直接向服务器发送请求,也就是说每次请求都必须向服务器发送。服务器接收到请求，然后判断资源是否变更，是则返回新内容，否则返回304，未变更。这个很容易让人产生误解，使人误以为是响应不被缓存。**实际上Cache-Control:  no-cache是会被缓存的，只不过每次在向客户端（浏览器）提供响应数据时，缓存都要向服务器评估缓存响应的有效性。** |
| no-store |          禁止一切缓存（这个才是响应不被缓存的意思）          |

##### ② 协商缓存的 header

  > `Last-Modified/If-Modified-Since`和`Etag/If-None-Match`是分别成对出现的，呈一一对应关系。
  >
  > `Last-Modified/If-Modified-Since`的时间精度是秒，而`Etag`可以更精确。
  >
  > `Etag`优先级是高于`Last-Modified`的，所以服务器会优先验证`Etag`。
  >
  > `Last-Modified/If-Modified-Since`是HTTP/1.0的头字段。

**1. Etag/If-None-Match**：

​	**Etag**：HTTP 1.1属性，它是由服务器（Apache或者其他工具）生成返回给前端，用来帮助服务器控制Web端的缓存验证。 Apache中，ETag的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。

​	**If-None-Match**：当资源过期时，浏览器发现响应头里有Etag,则再次像服务器请求时带上请求头if-none-match(值是Etag的值)。服务器收到请求进行比对，决定返回200或304。



**2. Last-Modified/If-Modified-Since**：

​	**Last-Modified**：浏览器向服务器发送的资源的最后的修改时间。

​	**If-Modified-Since**：当资源过期时（浏览器判断Cache-Control标识的max-age过期），发现响应头具有Last-Modified声明，则再次向服务器请求时带上头if-modified-since，表示请求时间。服务器收到请求后发现有if-modified-since则与被请求资源的最后修改时间进行对比（Last-Modified）,若最后修改时间较新（大），说明资源又被改过，则返回最新资源，HTTP 200 OK;若最后修改时间较旧（小），说明资源无新修改，响应HTTP 304 走缓存。



## CSRF和XSS

### CSRF

> CSRF（Cross-site request forgery）即**跨站请求伪造**。**是一种劫持受信任用户向服务器发送非预期请求**的攻击方式，通常情况下，它是**攻击者借助受害者的 Cookie 骗取服务器的信任**，但是它并不能拿到Cookie，也看不到Cookie 的内容，它能做的就是给服务器发送请求，然后执行请求中所描述的命令，以此来改变服务器中的数据，也就是并不能窃取服务器中的数据。

##### 类型：

- **自动发起 Get 请求**

  ```html
  <!DOCTYPE html>
  <html>
    <body>
      <h1>黑客的站点：CSRF 攻击演示</h1>
      <img src="https://jsliang.top/index.html?user=hacker&number=100">
    </body>
  </html>
  ```

  黑客将转账的请求接口隐藏在 `img` 标签内，欺骗浏览器这是一张图片资源。

  当该页面被加载时，浏览器会自动发起 `img` 的资源请求，如果服务器没有对该请求做判断的话，那么服务器就会认为该请求是一个转账请求，于是用户账户上的 100 块就被转移到黑客的账户上去了。

- **自动发起 POST 请求**

  ```html
  <!DOCTYPE html>
  <html>
  <body>
    <h1>黑客的站点：CSRF 攻击演示</h1>
    <form id='hacker-form' action="https://jsliang.top" method=POST>
      <input type="hidden" name="user" value="hacker" />
      <input type="hidden" name="number" value="100" />
    </form>
    <script>
      document.getElementById('hacker-form').submit();
    </script>
  </body>
  </html>
  ```

  在页面中构建了一个隐藏的表单，该表单的内容就是极客时间的转账接口。

  当用户打开该站点之后，这个表单会被自动执行提交；当表单被提交之后，服务器就会执行转账操作。

  因此使用构建自动提交表单这种方式，就可以自动实现跨站点 POST 数据提交。

- **引诱用户点击链接**

  ```html
  <div>
    <img width=150 src=http://images.xuejuzi.cn/1612/1_161230185104_1.jpg>
    </div>
  <div>
    <a href="https://jsliang.top?user=hacker&number=100" taget="_blank">
      点击下载美女照片
    </a>
  </div>
  ```

  传说中的色诱，或者 “点击即送 100w 元” 之类的。

##### 防御措施：

- 验证`token`：浏览器请求服务器时，服务器返回一个 `token` ，每个请求都需要同时带上` token` 和 `cookie` 才会被认为是合法请求。
- 验证`Referer`：通过验证请求头的 `Referer` 来验证来源站点，但请求头很容易伪造。
- 设置`SameSite`：设置 `cookie` 的 `SameSite` ，可以让 `cookie `不随跨站请求发出，但浏览器兼容不一致。

### XSS

> XSS（Cross Site Script）**跨站脚本攻击**。指的是**攻击者向网页注入恶意的客户端代码，通过恶意的脚本对客户端网页进行篡改，从而在用户浏览网页时，对用户浏览器进行控制或者获取用户隐私数据**的一种攻击方式。

##### 类型：

- **存储型**：即攻击被存储在服务端，常见的是在评论区插入攻击脚本，如果脚本被储存到服务端，那么所有看见对应评论的用户都会受到攻击。

- **反射型**：攻击者将脚本混在URL里，服务端接收到URL将恶意代码当做参数取出并拼接在HTML里返回，浏览器解析此HTML后即执行恶意代码。

- **DOM型**：攻击者通过各种手段将恶意脚本注入用户的页面中，例如通过网络劫持（WiFi 路由器劫持、本地恶意软件劫持等）在页面传输过程中修改 HTML 页面内容。

##### 防御措施：

- **输入检查**：对输入内容中的`script`和`<iframe>`等标签进行转义或者过滤。
- **设置 httpOnly**：很多XSS攻击目标都是窃取用户 `cookie` 伪造身份认证，设置此属性可防止JS获取 `cookie`。
- **开启CSP**：CSP(Content Security Policy) 网页安全策略，即开启白名单，可阻止白名单以外的资源加载和运行。



##  HTTP请求方法

1. GET：获取资源，幂等操作

2. HEAD：获取报文首部，和GET很像但是不返回报文主体，幂等操作

3. POST: 创建或更新资源，非幂等操作

4. PUT: 创建或更新资源本身，幂等操作

5. PATCH：对资源进行局部更新，幂等操作

6. DELETE：删除资源，和PUT功能相反，幂等操作

7. OPTIONS：查询服务器端支持的HTTP方法种类(幂等操作)：

   | 请求 | OPTIONS * HTTP/1.1 Host: lindaidai.wang                      |
   | ---- | ------------------------------------------------------------ |
   | 响应 | HTTP/1.1 200 OK Allow: GET, POST, HEAD, OPTIONS (返回服务器支持的方法) |

8. CONNECT：建立连接隧道，用于代理服务器，幂等操作

9. TRACE：追踪请求，查询发出去的请求是怎样被加工/篡改的，幂等操作。容易引发XST跨站追踪攻击。



## HTTP状态码

### 1开头

1xx(**临时响应**)表示临时响应并需要请求者继续执行操作的状态代码

* 100 (继续) 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。

* 101 (切换协议) 请求者已要求服务器切换协议，服务器已确认并准备切换。

### 2开头

  2xx (**成功**)表示成功处理了请求的状态代码

* **200 (成功) 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。**

* 201 (已创建) 请求成功并且服务器创建了新的资源。

* 202 (已接受) 服务器已接受请求，但尚未处理。

* 203 (非授权信息) 服务器已成功处理了请求，但返回的信息可能来自另一来源。

* **204 (无内容) 服务器成功处理了请求，但没有返回任何内容。**

* 205 (重置内容) 服务器成功处理了请求，但没有返回任何内容。

* **206 (部分内容) 服务器成功处理了部分 GET 请求。**

### 3开头

3xx (**重定向**) 表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。

* 300 (多种选择) 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。
* **301 (永久移动) 请求的网页已永久移动到新位置。 服务器返回此响应(对 GET 或 HEAD 请求的响应)时，会自动将请求者转到新位置。**
* **302 (临时移动) 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。**
* 303 (查看其他位置) 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。
* 304 (未修改) 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。
* 305 (使用代理) 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。
* 307 (临时重定向) 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。

### 4开头

4xx(**请求错误**) 这些状态代码表示请求可能出错，妨碍了服务器的处理。

* **400 (错误请求) 服务器不理解请求的语法。**
* **401 (未授权) 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。**
* **403 (禁止) 服务器拒绝请求。**
* **404 (未找到) 服务器找不到请求的网页。**
* 405 (方法禁用) 禁用请求中指定的方法。
* 406 (不接受) 无法使用请求的内容特性响应请求的网页。
* 407 (需要代理授权) 此状态代码与 401(未授权)类似，但指定请求者应当授权使用代理。
* 408 (请求超时) 服务器等候请求时发生超时。
* 409 (冲突) 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。
* 410 (已删除) 如果请求的资源已永久删除，服务器就会返回此响应。
* 411 (需要有效长度) 服务器不接受不含有效内容长度标头字段的请求。
* 412 (未满足前提条件) 服务器未满足请求者在请求中设置的其中一个前提条件。
* 413 (请求实体过大) 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。
* 414 (请求的 URI 过长) 请求的 URI(通常为网址)过长，服务器无法处理。
* 415 (不支持的媒体类型) 请求的格式不受请求页面的支持。
* 416 (请求范围不符合要求) 如果页面无法提供请求的范围，则服务器会返回此状态代码。
* 417 (未满足期望值) 服务器未满足"期望"请求标头字段的要求。

### 5开头

5xx(**服务器错误**)这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。

* **500 (服务器内部错误) 服务器遇到错误，无法完成请求。**
* 501 (尚未实施) 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。
* 502 (错误网关) 服务器作为网关或代理，从上游服务器收到无效响应。
* **503 (服务不可用) 服务器目前无法使用(由于超载或停机维护)。 通常，这只是暂时状态。**
* 504 (网关超时) 服务器作为网关或代理，但是没有及时从上游服务器收到请求。
* 505 (HTTP 版本不受支持) 服务器不支持请求中所用的 HTTP 协议版本。